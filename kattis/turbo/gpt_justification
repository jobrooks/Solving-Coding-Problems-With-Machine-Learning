To solve this problem, we can keep track of the position of each number in the initial array, and then simulate the turbosort algorithm, counting the number of swaps needed in each phase. We can keep two pointers, one to the first unsorted position and another to the last unsorted position, and alternate between finding the minimum and maximum unsorted numbers, swapping them to their final position, and updating the pointers accordingly.
The time complexity of this algorithm is O(n^2), as we are using the max and min functions to find the unsorted numbers in each phase. However, since we know that each number appears exactly once in the array, we can use a dictionary to keep track of the position of each number and avoid having to search for it in each phase. This reduces the time complexity of the algorithm to O(n log n), which is enough to solve the problem for the given input constraints.
