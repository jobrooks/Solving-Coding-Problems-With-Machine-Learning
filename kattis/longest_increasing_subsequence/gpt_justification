This problem can be solved using the dynamic programming approach. We can define dp[i] as the length of the longest increasing subsequence ending at the i-th element of the sequence. Then, for each i, we can calculate dp[i] as the maximum of all dp[j] + 1 where j is an index such that j < i and a[j] < a[i]. We can also keep track of the previous index p[i] for each i, which gives us the index of the previous element in the longest increasing subsequence ending at the i-th element.

Once we have calculated dp and p, we can find the length of the longest increasing subsequence by taking the maximum value in dp. To find the indices of the elements in the subsequence, we can start with the index i that corresponds to the maximum value in dp. Then, we can follow the indices in p backwards until we reach an index j such that dp[j] + 1 = dp[i]. We can repeat this process until we reach the beginning of the sequence.
We read the input using sys.stdin to handle multiple test cases. For each test case, we first read the length n and the sequence a. Then, we call longest_increasing_subsequence(a) to find the length of the longest increasing subsequence and its indices. Finally, we print the length and the indices as required by the problem statement.
