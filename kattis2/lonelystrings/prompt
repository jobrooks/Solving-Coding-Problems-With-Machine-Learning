String art and image by SimpleVibesStudio (Etsy); Used with permission A binary string has either even parity or odd parity, depending on whether it contains an even or an odd number of 1’s, respectively. Now suppose a binary string, S, has been partitioned into m geq 2 nonempty substrings, S = S_1 S_2 ldots S_ m. The neighbours of any substring S_ i are the substrings immediately adjacent to it, so every substring has two neighbours, except S_1, which has only a right neighbour, and S_ m, which has only a left neighbour. We say that a substring is lonely if it has no neighbour with the same parity as itself. Given a binary string, S, in how many ways can S be partitioned into two or more nonempty substrings so that no substring is lonely? Input The input consists of a single binary string, i.e., a string composed entirely of characters from { texttt{0}, texttt{1}} . The length of this string is between 2 and 2, 000, inclusive. Output Let w be the number of ways S can be partitioned into two or more nonempty substrings so that no substring is lonely. If w is greater than 100, print a single line containing w; since w may be large, reduce it mod (10^9 + 33). If w is at most 100, first print a line containing w. Then print w lines containing the partitions of the input string, one per line. Represent each partition as a string of characters from { texttt{0}, texttt{1}, texttt{/} } , using / as a separator between adjacent substrings. Order these w strings lexicographically (with the ASCII/Unicode rule that ‘/’ is before ‘0’, which in turn is before ‘1’). See the first two sample outputs for examples. Sample Input 1 Sample Output 1 01010 5 0/101/0 0/1010 01/010 010/10 0101/0 Sample Input 2 Sample Output 2 0000 7 0/0/0/0 0/0/00 0/00/0 0/000 00/0/0 00/00 000/0 Sample Input 3 Sample Output 3 00000000 127